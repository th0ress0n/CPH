"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var eventemitter3_1 = require("eventemitter3");
var logical_address_1 = require("./models/logical-address");
var operation_code_1 = require("./models/operation-code");
var power_status_1 = require("./models/power-status");
var debuglib = require("debug");
var debug = debuglib('cec:commander');
/**
 * CEC device commander
 *
 * This class provides you with an interface to execute common actions on other CEC-connected devices on the cec bus.
 * This class also provides events signaling other devices turning everything else off, the tv going off, etc.
 * These actions include turning up or down the volume, changing the source on a tv, etc.
 *
 * Most of the message frames are sourced from: http://www.cec-o-matic.com/
 */
var Commander = (function (_super) {
    __extends(Commander, _super);
    function Commander(monitor) {
        var _this = _super.call(this) || this;
        _this.monitor = monitor;
        return _this;
    }
    /**
     * Turn off all devices on the cec-bus.
     */
    Commander.prototype.broadcastStandby = function () {
        return this.monitor.executeOperation(logical_address_1.LogicalAddress.BROADCAST, operation_code_1.OperationCode.STANDBY);
    };
    /**
     * Set the power state for the given device.
     *
     * @param state The state to set the device to.
     * @param target The target of the call, defaults to the tv.
     */
    Commander.prototype.setPowerState = function (state, target) {
        if (target === void 0) { target = logical_address_1.LogicalAddress.TV; }
        if (state === power_status_1.PowerStatus.STANDBY) {
            return this.monitor.executeOperation(target, operation_code_1.OperationCode.STANDBY);
        }
        else if (state === power_status_1.PowerStatus.ON) {
            return this.monitor.executeOperation(target, operation_code_1.OperationCode.IMAGE_VIEW_ON);
        }
        else {
            return false;
        }
    };
    /**
     * Get the current powerstate of the given target device.
     *
     * @param target Target cec-device to request the power status for.
     */
    Commander.prototype.getPowerState = function (target) {
        if (target === void 0) { target = logical_address_1.LogicalAddress.TV; }
        if (this.monitor.executeOperation(target, operation_code_1.OperationCode.GIVE_DEVICE_POWER_STATUS)) {
            return this.waitForOperationResponse(operation_code_1.OperationCode.REPORT_POWER_STATUS, function (packet) { return packet.args[0]; });
        }
        return Promise.reject(new Error('Unable to request the power status.'));
    };
    /**
     * Press the given button on this virtual remote.
     *
     * @param button The button being pressed (and released).
     * @param target The target of the button press (receiver or TV realistically, but can be any logical address).
     */
    Commander.prototype.pressButton = function (button, target) {
        if (target === void 0) { target = logical_address_1.LogicalAddress.TV; }
        if (this.monitor.executeOperation(target, operation_code_1.OperationCode.USER_CONTROL_PRESSED, [button])) {
            if (this.monitor.executeOperation(target, operation_code_1.OperationCode.USER_CONTROL_RELEASE)) {
                return true;
            }
            debug('Unable to send the user control key-release operation.');
            return false;
        }
        debug('Unable to send the user control key-down operation.');
        return false;
    };
    /**
     * Helper method that handles timing out of promises.
     *
     * @param waitForOpcode The opcode to wait for as a response to a call you have already done (Or are about to do).
     * @param resolverMethod Resolver.
     */
    Commander.prototype.waitForOperationResponse = function (waitForOpcode, resolverMethod) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var isResolved = false, resolverFunction = function (key, packet) {
                isResolved = true;
                resolve(resolverMethod(packet));
            };
            _this.monitor.once("op." + operation_code_1.OperationCode[waitForOpcode], resolverFunction);
            setTimeout(function () {
                _this.monitor.off("op." + operation_code_1.OperationCode[waitForOpcode], resolverFunction);
                reject(new Error('Target cec-device took too long to respond to the request.'));
            }, 5000);
        });
    };
    return Commander;
}(eventemitter3_1.EventEmitter));
exports.Commander = Commander;
//# sourceMappingURL=commander.js.map