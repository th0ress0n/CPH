"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var child_process_1 = require("child_process");
var eventemitter3_1 = require("eventemitter3");
var emit_lines_1 = require("./lib/emit-lines");
var operation_code_1 = require("./models/operation-code");
var logical_address_1 = require("./models/logical-address");
var debuglib = require("debug");
var debug = debuglib('cec:monitor');
var debugRaw = debuglib('cec:monitor:raw');
var logicalAddressAssignRegexp = /^DEBUG:[ \[\d\]\t]+AllocateLogicalAddresses - device '\d', type '[\w ]+', LA '(\w)'/g;
/**
 * CEC Monitor Interface
 *
 * This class provides a way to work with (read out, and write to) the cec-client cli application.
 * It does not contain any (business)-logic, just the interfacing code. If you need a direct interface to the cec-bus, this is the class you need.
 */
var CecMonitor = (function (_super) {
    __extends(CecMonitor, _super);
    /**
     * @param deviceName The name of this monitor instance, as used on the cec-bus.
     * @param deviceAddress The address/type/slot to use for this device on the CEC bus. If not available, will take next in same category!
     * @param monitorMode Whether or not to emit operation events for all messages decoded on the bus, or only messages being send to our device or the broadcasting address.
     */
    function CecMonitor(deviceName, deviceAddress, monitorMode, autostart) {
        if (deviceName === void 0) { deviceName = 'node-hdmi-cec'; }
        if (deviceAddress === void 0) { deviceAddress = logical_address_1.LogicalAddress.RECORDINGDEVICE1; }
        if (monitorMode === void 0) { monitorMode = false; }
        if (autostart === void 0) { autostart = true; }
        var _this = _super.call(this) || this;
        _this.deviceName = deviceName;
        _this.deviceAddress = deviceAddress;
        _this.monitorMode = monitorMode;
        /**
         * Whether or not the cec-client is ready to write commands.
         */
        _this.ready = false;
        /**
         * The handlers that can convert input from the cec-client to events on this class.
         */
        _this.stdinHandlers = [
            {
                contains: 'waiting for input',
                callback: function (line) {
                    debug('ready');
                    _this.emit('ready', _this);
                }
            },
            {
                match: /^TRAFFIC:/g,
                callback: _this.processTraffic.bind(_this)
            },
            {
                match: logicalAddressAssignRegexp,
                callback: _this.setDeviceAddress.bind(_this)
            }
        ];
        if (autostart) {
            _this.start();
        }
        return _this;
    }
    /**
     * Start the monitor, and let it start listening.
     *
     * @param clientName
     * @param rest
     */
    CecMonitor.prototype.start = function (clientName) {
        var _this = this;
        if (clientName === void 0) { clientName = 'cec-client'; }
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        this.clientName = clientName;
        this.params = Array.from(rest).slice(0);
        if (this.deviceName != null) {
            this.params.push('-o');
            this.params.push(this.deviceName);
        }
        if (this.deviceName != null) {
            this.params.push('-t');
            this.params.push(this.convertLogicalAddressToClientType(this.deviceAddress));
        }
        this.client = child_process_1.spawn(this.clientName, this.params);
        emit_lines_1.default(this.client.stdout);
        this.client.on('close', this.onClose);
        this.client.stdout.on('line', function (line) {
            _this.emit('data', line);
            debugRaw("rx: \"" + line + "\"");
            _this.processLine(line);
        });
    };
    /**
     * Stop the monitor class from listening and kill the cec-client process.
     */
    CecMonitor.prototype.stop = function () {
        debug('stop (by parent)');
        this.emit('stop', this);
        if (this.client) {
            this.client.kill('SIGINT');
        }
    };
    /**
     * Called when the child process exits.
     */
    CecMonitor.prototype.onClose = function () {
        debug('stop (by child)');
        this.emit('stop', this);
    };
    /**
     * Send a raw message to the cec-client.
     *
     * @param message The raw message to send.
     */
    CecMonitor.prototype.send = function (message) {
        return this.client.stdin.write(message + '\n');
    };
    /**
     * Send a cec-command by its numbers.
     *
     * When using this version, you need to include the target and source yourself!
     * Check http://www.cec-o-matic.com/ to find messages to send.
     *
     * @param command List of the numeric representations of the commands to send.
     */
    CecMonitor.prototype.sendCommand = function () {
        var command = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            command[_i] = arguments[_i];
        }
        return this.send('tx ' + command.map(function (hex) { return hex.toString(16); }).join(':'));
    };
    /**
     * Send a cec-command by its numbers and set the target.
     *
     * @param target The target's cec-address.
     * @param opcode The operation to execute.
     * @param params List of the numeric representations of the parameters to send.
     */
    CecMonitor.prototype.executeOperation = function (target, opcode, params) {
        var base = "tx " + this.deviceAddress.toString(16) + target.toString(16) + ":" + opcode.toString(16);
        if (params && params.length > 0) {
            return this.send(base + ':' + params.map(function (hex) { return hex.toString(16); }).join(':'));
        }
        return this.send(base);
    };
    /**
     * Send a cec-command by its type and set the target.
     *
     * @param target The target's cec-address.
     * @param opcode The operation to execute.
     * @param param Boolean parameter to send.
     */
    CecMonitor.prototype.executeOperationWithBoolean = function (target, opcode, param) {
        return this.executeOperation(target, opcode, [param ? 0x01 : 0x00]);
    };
    /**
     * Send a cec-command by its type and set the target.
     *
     * @param target The target's cec-address.
     * @param opcode The operation to execute.
     * @param param Integer parameter to send.
     */
    CecMonitor.prototype.executeOperationWithInteger = function (target, opcode, param) {
        var bytes = [];
        var i = 3;
        do {
            bytes[--i] = param & (255);
            param = param >> 8;
        } while (i);
        return this.executeOperation(target, opcode, bytes);
    };
    /**
     * Send a cec-command by its type and set the target.
     *
     * @param target The target's cec-address.
     * @param opcode The operation to execute.
     * @param param Integer parameter to send.
     */
    CecMonitor.prototype.executeOperationWithString = function (target, opcode, param) {
        return this.executeOperation(target, opcode, param.split('').map(function (x) { return x.charCodeAt(0); }));
    };
    /**
     * Send a cec-command by its numbers and set the target.
     *
     * @param command List of the numeric representations of the commands to send.
     */
    CecMonitor.prototype.executeBroadcastOperation = function (opcode, params) {
        return this.executeOperation(logical_address_1.LogicalAddress.BROADCAST, opcode, params);
    };
    /**
     * Processes a log line to set our own device address.
     *
     * @param line The address to change to as extracted from the logs.
     */
    CecMonitor.prototype.setDeviceAddress = function (line) {
        var result = logicalAddressAssignRegexp.exec(line);
        if (result == null) {
            return;
        }
        this['deviceAddress'] = parseInt(result[0], 16);
        debug("device address set to " + this.deviceAddress.toString(16));
    };
    /**
     * Process an incomming line.
     *
     * @param line The line that was emitted by the cec-client.
     */
    CecMonitor.prototype.processLine = function (line) {
        this.emit('line', line);
        var executed = 0;
        for (var _i = 0, _a = this.stdinHandlers; _i < _a.length; _i++) {
            var handler = _a[_i];
            if (handler.contains != null) {
                if (line.indexOf(handler.contains) >= 0) {
                    handler.callback(line);
                    executed++;
                }
            }
            if (handler.match != null) {
                var matches = line.match(handler.match);
                if (matches != null && matches.length > 0) {
                    handler.callback(line);
                    executed++;
                }
            }
            if (handler.fn != null) {
                if (handler.fn(line)) {
                    handler.callback(line);
                    executed++;
                }
            }
        }
        if (executed > 0) {
            debugRaw("executed " + executed + " handlers");
        }
        return executed;
    };
    //region cec-client Monitor-mode Traffic Processing
    /**
     * Process/parse an incomming traffic line from cec-client.
     *
     * @param traffic The line as it came from the cec-client.
     */
    CecMonitor.prototype.processTraffic = function (traffic) {
        var packet = {
            tokens: [],
            source: 0,
            target: 0,
            opcode: 0,
            args: [],
        };
        var command = traffic.substr(traffic.indexOf(']\t') + 2); // "<< 0f:..:.."
        command = command.substr(command.indexOf(' ') + 1); // "0f:..:.."
        var tokens = command.split(':'); // 0f .. ..
        if (tokens != null) {
            packet.tokens = tokens;
        }
        if (tokens != null && tokens.length > 0) {
            packet.source = parseInt(tokens[0][0], 16);
            packet.target = parseInt(tokens[0][1], 16);
        }
        if (tokens != null && tokens.length > 1) {
            packet.opcode = parseInt(tokens[1], 16);
            packet.args = tokens.slice(2, tokens.length + 1).map(function (hexString) { return parseInt(hexString, 16); });
        }
        debug('parsed packet', packet);
        return this.processPacket(packet);
    };
    /**
     * Converts a parsed packet to events on this emitter.
     *
     * @param packet Parsed packet to be emitted as event.
     */
    CecMonitor.prototype.processPacket = function (packet) {
        // no opcode?
        if (!(packet.tokens != null && packet.tokens.length > 1)) {
            this.emit('polling', packet);
            return false;
        }
        // check if we are in monitoring mode
        if (!this.monitorMode && packet.target !== this.deviceAddress && packet.target !== logical_address_1.LogicalAddress.BROADCAST) {
            return false;
        }
        // emit packet
        this.emit('packet', packet);
        switch (packet.opcode) {
            // ---------------------------------------------------------------------- #
            //    #OSD
            case operation_code_1.OperationCode.SET_OSD_NAME:
                if (packet.args.length == 0) {
                    break;
                }
                var osdname = String.fromCharCode.apply(null, packet.args);
                this.emit('SET_OSD_NAME', packet, osdname);
                return true;
            // ---------------------------------------------------------------------- #
            //    #SOURCE / ADDRESS
            case operation_code_1.OperationCode.ROUTING_CHANGE:
                if (packet.args.length < 4) {
                    break;
                }
                var from = (packet.args[0] << 8) | packet.args[1];
                var to = (packet.args[2] << 8) | packet.args[3];
                this.emit('ROUTING_CHANGE', packet, from, to);
                return true;
            case operation_code_1.OperationCode.ACTIVE_SOURCE:
                if (packet.args.length < 2) {
                    break;
                }
                var source = (packet.args[0] << 8) | packet.args[1];
                this.emit('ACTIVE_SOURCE', packet, source);
                return true;
            case operation_code_1.OperationCode.REPORT_PHYSICAL_ADDRESS:
                if (packet.args.length < 2) {
                    break;
                }
                source = (packet.args[0] << 8) | packet.args[1];
                this.emit('REPORT_PHYSICAL_ADDRESS', packet, source, packet.args[2]);
                return true;
            // ---------------------------------------------------------------------- #
            //    #OTHER
            default:
                var opcodes = operation_code_1.OperationCode;
                for (var key in opcodes) {
                    var opcode = opcodes[key];
                    if (opcode === packet.opcode) {
                        if (key != null && key.length > 0) {
                            this.emit.apply(this, ['op.' + key, key, packet].concat(Array.from(packet.args)));
                        }
                        return true;
                    }
                }
        }
        // not handled
        return false;
    };
    //endregion
    /**
     * Convert a logical address to an type argument usable with cec-client.
     * @param address Address to convert
     */
    CecMonitor.prototype.convertLogicalAddressToClientType = function (address) {
        switch (address) {
            case logical_address_1.LogicalAddress.AUDIOSYSTEM:
                return 'a';
            case logical_address_1.LogicalAddress.PLAYBACKDEVICE1:
            case logical_address_1.LogicalAddress.PLAYBACKDEVICE2:
            case logical_address_1.LogicalAddress.PLAYBACKDEVICE3:
                return 'p';
            case logical_address_1.LogicalAddress.TUNER1:
            case logical_address_1.LogicalAddress.TUNER2:
            case logical_address_1.LogicalAddress.TUNER3:
            case logical_address_1.LogicalAddress.TUNER4:
                return 't';
            default:
                return 'r';
        }
    };
    return CecMonitor;
}(eventemitter3_1.EventEmitter));
exports.CecMonitor = CecMonitor;
var DeviceAddressMap = {};
DeviceAddressMap[logical_address_1.LogicalAddress.RECORDINGDEVICE1] = 'r';
//# sourceMappingURL=cec-monitor.js.map